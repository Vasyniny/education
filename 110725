-----

Понимание, когда код холодильника может быть изменен, а когда уже нет, критически важно для целостности данных испытаний. Ваш текущий код уже содержит логику, которая частично это регулирует (например, `edKod[i].Enabled := True;` при начале теста и затем `edKod[i].Enabled := False;` после определенных действий).

Давайте формализуем **алгоритм для управления возможностью изменения кода** во время испытания.

-----

## Алгоритм Управления Изменением Кода Холодильника

Основная идея состоит в том, чтобы **разрешать изменение кода только на начальных этапах испытания** (до того, как будут собраны первые значимые данные или тест перейдет в активную фазу мониторинга). Как только испытание переходит к сбору критических данных или достигает первой контрольной точки, возможность изменения кода должна блокироваться.

### Состояния Возможности Изменения Кода:

1.  **Разрешено (AllowEdit)**: Код можно вводить или изменять.
2.  **Заблокировано (BlockEdit)**: Код нельзя изменить.

### Факторы, Влияющие на Блокировку:

  * **`StatePos[i]` (Состояние позиции теста)**:
      * `0`: Ожидание начала теста. **Разрешено**.
      * `1`: Тест в процессе. Может быть **разрешено** на ранних стадиях, затем **заблокировано**.
      * `2`: Ожидание данных / Финальная проверка. **Заблокировано**.
      * `3`: Тест завершен. **Заблокировано**.
  * **`flParams[i]` (Параметры модели загружены)**: Когда `flParams[i]` становится `True`, это означает, что модель ХП идентифицирована и её параметры загружены. Часто это хороший момент для блокировки изменения кода.
  * **`nCheckPoint[i]` (Номер текущей контрольной точки)**: Если тест уже достиг первой контрольной точки (`nCheckPoint[i] > 0`), изменение кода, скорее всего, должно быть заблокировано.
  * **`Data[i].bgChTm` (Началось контрольное время)**: Если `bgChTm` стало `True`, это однозначно указывает на активный сбор данных в контрольной точке, и изменение кода должно быть заблокировано.

-----

### Подробный Алгоритм:

Мы будем управлять свойством `Enabled` для компонента `edKod[i]` и его цветом (`clYellow` для редактирования, `clWindow` для заблокированного).

1.  **Начальное Состояние (После запуска программы или сброса позиции):**

      * **Где**: В процедурах `FormCreate`, `ClearComponent`, или при инициализации новой позиции после `BtnRes_XClick`.
      * **Действие**: `edKod[i].Enabled := True;`
      * `edKod[i].Color := clYellow;` (или `clWindow` если нет кода, но готов к вводу)
      * `lModel[i].Enabled := False;` (модель еще не определена)

2.  **При Обнаружении Начала Испытания (В `HandleState0(i)`):**

      * **Условие**: `StatePos[i]` переходит из `0` в `1` (после 3 последовательных `valW[i] >= UstW`).
      * **Действие**:
          * `edKod[i].Enabled := True;` (для возможности **первичного** ввода или подтверждения кода).
          * `edKod[i].Color := clYellow;`
          * `edKod[i].SetFocus;` (для удобства оператора).
          * `lModel[i].Enabled := True;` (теперь модель может быть показана).
          * **Важно**: **Код еще НЕ блокируется здесь**, потому что оператор мог запустить тест "вслепую" и только теперь вводит код ХП.

3.  **При Вводе / Изменении Кода (В обработчике `edKod[i]Change` или `edKod[i]KeyDown` по Enter):**

      * **Где**: Например, в `edKod_XKeyDown` (по нажатию Enter), когда код введен и подтвержден.
      * **Условие**: Оператор ввел код, и он был успешно найден в базе (`dm.spXP.Locate` вернул `True`), и `flParams[i]` установлено в `True`.
      * **Действие**:
          * `edKod[i].Enabled := False;` (**Блокировка**).
          * `edKod[i].Color := clWindow;` (меняем цвет на стандартный, показывая, что поле неактивно).
          * `Data[nPos].kodXP := edKod[nPos].Text;` (сохраняем код).
          * **Проверка на "пропущенные" контрольные точки**: Если после загрузки параметров ХП выясняется, что тест уже прошел фазу, где должна была быть контрольная точка, которая могла быть "пропущена" из-за позднего ввода кода, то:
              * Выводим предупреждение.
              * **Возможность**: Сбросить тест (`ClearComponent`) или принудительно перевести в `StatePos=2` для ручного ввода данных (если это критично). В вашем коде есть:
                ```delphi
                if (CheckPointIsMissed(nPos)) then // Проверяем, не пропущена ли контрольная точка
                begin
                  MessageDlg('Контрольная точка уже прошла!', mtWarning, [mbOK], 0);
                  ReturnPrevCode(nPos); // Возвращаем предыдущий код или сбрасываем поле
                  Exit;
                end;
                ```
                Эта логика **уже предотвращает изменение кода**, если контрольная точка "пропущена".

4.  **При Наступлении Первой Контрольной Точки или Критического События (В `ProcessCheckPoint(i)` или `HandleState1(i)`):**

      * **Условие 1**: `Data[i].bgChTm` становится `True` (то есть, началась **первая** контрольная точка, и `nCheckPoint[i]` стало `1`).
      * **Условие 2**: Если `chMetod[i]` - 'Off' и `numOffCmp[i]` становится `1` (первое отключение компрессора), и это событие вызывает сохранение параметров (`SaveParamIsp`).
      * **Действие**: На этом этапе код **должен быть заблокирован**, если он еще не был заблокирован вручную после ввода оператором. Это гарантирует, что данные не будут связаны с неверной моделью.
          * `edKod[i].Enabled := False;`
          * `edKod[i].Color := clWindow;`

5.  **На протяжении Остальных Состояний (В `HandleState2(i)` и `HandleState3(i)`):**

      * **Действие**: Поле `edKod[i]` всегда должно оставаться **заблокированным** (`Enabled := False`). Любые попытки изменить его не должны быть разрешены, поскольку данные уже активно собираются или тест завершен.

### Реализация в Коде:

Ваш текущий код уже близок к этому алгоритму. Главное — убедиться, что `edKod[i].Enabled := False;` и `edKod[i].Color := clWindow;` вызываются в нужный момент.

```delphi
// В HandleState0(i):
procedure TfMain.HandleState0(i: Integer);
begin
  // ... (предыдущий код) ...

  if NumVal[i] = 3 then // Если 3 последовательных показания выше порога
  begin
    // Начало нового теста
    edKod[i].Enabled := True; // Включаем для ввода кода (если не ввели ранее)
    edKod[i].Color := clYellow;
    edKod[i].SetFocus;
    lModel[i].Enabled := True;
    BtnState[i].Glyph.LoadFromFile(MyDir + 'Img\Green.bmp');
    pCycl[i].Caption := '0';
    StatePos[i] := 1; // Переход в состояние "тест в процессе"

    // ... (остальные инициализации) ...
  end;
  // ...
end;

// В edKod_XKeyDown (когда пользователь нажимает Enter в поле кода)
// или в edKod_XExit (когда поле теряет фокус, если код валиден)
procedure TfMain.edKod_XKeyDown(Sender: TObject; var Key: Word; Shift: TShiftState);
var
  nPos: Integer;
begin
  if Key = VK_RETURN then // При нажатии Enter
  begin
    nPos := StrToInt(Copy(TEdit(Sender).Name, Length('edKod_') + 1, 10)); // Получаем номер позиции
    if (edKod[nPos].Text = '') then // Если код пуст, очищаем
    begin
      ClearComponent(nPos);
      Exit;
    end;

    // Проверяем, изменился ли код
    if (Data[nPos].kodXP <> edKod[nPos].Text) then
    begin
      // ... (логика сохранения старых данных, DataInRecords, если тест уже шел) ...

      // Пытаемся загрузить параметры для нового кода
      if ParamsXP(nPos) then // Если параметры найдены и загружены
      begin
        flParams[nPos] := True; // Модель загружена
        // !!! Вот здесь блокируем поле кода после успешной загрузки параметров
        edKod[nPos].Enabled := False;
        edKod[nPos].Color := clWindow;
        Data[nPos].kodXP := edKod[nPos].Text; // Сохраняем код в Data
        // ... (остальная логика, связанная с проверкой "КамАЗ", FnF и т.д.) ...

        // Проверка на пропущенные контрольные точки после ввода кода
        if (CheckPointIsMissed(nPos)) then
        begin
          MessageDlg('Контрольная точка уже прошла!', mtWarning, [mbOK], 0);
          ReturnPrevCode(nPos); // Это вернет старый код и, возможно, разблокирует поле
          // Или, если это недопустимо, сразу переводим в StatePos 3 и сбрасываем позицию
          // StatePos[nPos] := 3; BtnRes_[nPos].Enabled := True;
          Exit;
        end;
        // ... (логика lChTm[nPos].Visible) ...
      end
      else // Если параметры не найдены
      begin
        MessageDlg('ХП с кодом "' + edKod[nPos].Text + '" не найдено!', mtError, [mbOK], 0);
        ReturnPrevCode(nPos); // Возвращаем предыдущий код или сбрасываем поле
      end;
    end;
    Key := 0; // Поглощаем Enter
  end;
end;

// В HandleState1(i) (или ProcessCheckPoint(i), если там есть логика, которая должна блокировать)
// Например, при начале первой контрольной точки
procedure TfMain.ProcessCheckPoint(i: Integer);
begin
  // ... (логика активации контрольной точки) ...
  if (not Data[i].bgChTm) and (nCheckPoint[i] <= dm.checkTime.RecordCount) then
  begin
    // ... (условия для dm.checkTime.Locate) ...
    if ( (dm.checkTime['Method'] = 'Time' ) and (Data[i].mmCur >= dm.checkTime['Time_bgn']) ) or
       ( (dm.checkTime['Method'] = 'Cycle') and (numOffCmp[i] >= dm.checkTime['Cycle_bgn']) ) then
    begin
      Data[i].bgChTm := True;
      lChTm[i].Visible := True;
      // ... (фиксация bgnTokr, bgnWch) ...

      // !!! Здесь можно ДОПОЛНИТЕЛЬНО заблокировать поле кода,
      // если оно еще не было заблокировано после ввода
      if edKod[i].Enabled then // Если оно еще активно
      begin
        edKod[i].Enabled := False;
        edKod[i].Color := clWindow;
      end;
      Exit;
    end;
  end;
  // ... (остальная логика ProcessCheckPoint) ...
end;
```

### Резюме:

Ключ к управлению изменением кода — это **постепенное ужесточение контроля**. Сначала поле активно для ввода, затем, как только введенный код подтвержден и тест переходит в фазу активного сбора данных (загружены параметры, или началась первая контрольная точка), поле блокируется. Это предотвращает порчу данных из-за ошибочного или злонамеренного изменения кода ХП в середине испытания.

Убедитесь, что логика сброса позиции (`ClearComponent`) всегда возвращает `edKod[i]` в состояние `Enabled := True` и `Color := clYellow`, чтобы оператор мог начать новый тест.

Надеюсь, это объяснение алгоритма и его реализация поможет вам\!
